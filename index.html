<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Webcam Geometry Physics</title>
    <!-- Matter.js for Physics -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <!-- MediaPipe Pose for Skeletal Tracking -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            color: #eee;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #00ffcc;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.2);
            backdrop-filter: blur(5px);
            z-index: 10;
            max-width: 300px;
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 1.2rem;
            color: #00ffcc;
            text-transform: uppercase;
            letter-spacing: 2px;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }

        .status {
            font-size: 0.8rem;
            margin-top: 10px;
            color: #aaa;
            font-family: monospace;
        }

        #start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5,5,5,0.95);
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        #start-overlay h2 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: #fff;
            text-shadow: 0 0 10px #00ffcc;
        }

        #start-btn {
            background: transparent;
            color: #00ffcc;
            border: 2px solid #00ffcc;
            padding: 15px 40px;
            font-size: 1.2rem;
            border-radius: 30px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s;
            margin-top: 20px;
        }

        #start-btn:hover {
            background: #00ffcc;
            color: #000;
            box-shadow: 0 0 20px #00ffcc;
        }

        .loader {
            display: none;
            border: 4px solid #333;
            border-top: 4px solid #00ffcc;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-top: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>

    <!-- Startup Overlay -->
    <div id="start-overlay">
        <h2>GEOMETRY INTERFACE</h2>
        <p style="max-width: 500px; color: #888; line-height: 1.5;">
            Uses AI to map your skeleton to a physics simulation.<br>
            Your body becomes the geometry that interacts with the digital world.
        </p>
        <button id="start-btn">Initialize System</button>
        <div class="loader" id="loader"></div>
        <p id="loading-text" style="margin-top: 10px; color: #555; display: none;">Loading AI Models...</p>
    </div>

    <!-- UI Controls -->
    <div id="ui-layer" style="display:none;">
        <h1>System Active</h1>
        <div class="status" id="fps-counter">FPS: 0</div>
        <div class="status" id="obj-counter">Particles: 0</div>
        <div style="margin-top: 15px; border-top: 1px solid #444; padding-top: 10px;">
            <button id="reset-btn" style="background: #333; color: #fff; border: none; padding: 8px 12px; width: 100%; cursor: pointer;">Reset Particles</button>
        </div>
    </div>

    <div id="canvas-container">
        <canvas id="world"></canvas>
    </div>

    <!-- Hidden Video for AI Processing -->
    <video id="webcam" autoplay playsinline style="display:none;"></video>

    <script>
        // --- Configuration ---
        const CONFIG = {
            particleCount: 150,
            particleSize: { min: 2, max: 8 },
            skeletonThickness: 15, // Physics thickness of your arms/video
            smoothFactor: 0.5 // Smoothing for jittery AI detection
        };

        // --- Globals ---
        let engine, video, canvas, ctx;
        let width, height;
        let particles = [];
        let pose; // MediaPipe Pose instance
        
        // Physics Bodies for Skeleton
        // We track key landmarks: 
        // 11=Left Shoulder, 12=Right Shoulder, 13=Left Elbow, 14=Right Elbow, 
        // 15=Left Wrist, 16=Right Wrist, 0=Nose
        let skeletonBodies = {
            head: null,
            l_shoulder: null, r_shoulder: null,
            l_elbow: null, r_elbow: null,
            l_wrist: null, r_wrist: null
        };
        
        // Visual Connections (pairs of landmarks to draw lines between)
        const connections = [
            ['l_shoulder', 'r_shoulder'],
            ['l_shoulder', 'l_elbow'],
            ['l_elbow', 'l_wrist'],
            ['r_shoulder', 'r_elbow'],
            ['r_elbow', 'r_wrist'],
            ['l_shoulder', 'head'],
            ['r_shoulder', 'head']
        ];

        // Matter.js Aliases
        const Engine = Matter.Engine,
              Bodies = Matter.Bodies,
              Composite = Matter.Composite,
              Events = Matter.Events,
              Common = Matter.Common,
              Body = Matter.Body,
              Vector = Matter.Vector;

        // --- Initialization ---

        const startBtn = document.getElementById('start-btn');
        const loader = document.getElementById('loader');
        const loadText = document.getElementById('loading-text');

        startBtn.addEventListener('click', async () => {
            startBtn.style.display = 'none';
            loader.style.display = 'block';
            loadText.style.display = 'block';

            try {
                await initCamera();
                await initPose();
                initPhysics();
                
                // Hide overlay
                document.getElementById('start-overlay').style.display = 'none';
                document.getElementById('ui-layer').style.display = 'block';
                
                // Start Loop
                requestAnimationFrame(loop);
            } catch (err) {
                console.error(err);
                alert("Error initializing: " + err.message);
                startBtn.style.display = 'block';
                loader.style.display = 'none';
            }
        });

        async function initCamera() {
            video = document.getElementById('webcam');
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { width: 640, height: 480, facingMode: 'user' },
                audio: false
            });
            video.srcObject = stream;
            return new Promise(resolve => {
                video.onloadedmetadata = () => {
                    video.play();
                    resolve();
                };
            });
        }

        async function initPose() {
            pose = new Pose({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
            }});
            
            pose.setOptions({
                modelComplexity: 1,
                smoothLandmarks: true,
                enableSegmentation: false,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            pose.onResults(onPoseResults);
        }

        function initPhysics() {
            canvas = document.getElementById('world');
            ctx = canvas.getContext('2d');
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;

            engine = Engine.create();
            engine.gravity.y = 0; // Zero gravity
            engine.gravity.scale = 0;

            // Boundaries
            const walls = [
                Bodies.rectangle(width/2, -50, width, 100, { isStatic: true }),
                Bodies.rectangle(width/2, height+50, width, 100, { isStatic: true }),
                Bodies.rectangle(-50, height/2, 100, height, { isStatic: true }),
                Bodies.rectangle(width+50, height/2, 100, height, { isStatic: true })
            ];
            Composite.add(engine.world, walls);

            // Create Skeleton Bodies (Static kinetic bodies that we move manually)
            // We make them circles for smooth collisions
            const opts = { 
                isStatic: true, // We control position manually
                render: { fillStyle: '#00ffcc' } 
            };
            
            for (let key in skeletonBodies) {
                // Determine size based on body part
                let r = (key === 'head') ? 30 : CONFIG.skeletonThickness;
                skeletonBodies[key] = Bodies.circle(-100, -100, r, opts); // Start off screen
                Composite.add(engine.world, skeletonBodies[key]);
            }

            // Fill with particles
            spawnParticles();

            // Particle maintainer
            Events.on(engine, 'afterUpdate', () => {
                // Wrap particles
                for (let p of particles) {
                    if (p.position.x < 0) Body.setPosition(p, { x: width, y: p.position.y });
                    if (p.position.x > width) Body.setPosition(p, { x: 0, y: p.position.y });
                    if (p.position.y < 0) Body.setPosition(p, { x: p.position.x, y: height });
                    if (p.position.y > height) Body.setPosition(p, { x: p.position.x, y: 0 });
                    
                    // Add slight random force to keep them moving if stuck
                    if (p.speed < 0.2) {
                        Body.applyForce(p, p.position, {
                            x: (Math.random() - 0.5) * 0.0001,
                            y: (Math.random() - 0.5) * 0.0001
                        });
                    }
                }
            });
        }

        function spawnParticles() {
            Composite.remove(engine.world, particles);
            particles = [];
            for(let i=0; i<CONFIG.particleCount; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                const size = Common.random(CONFIG.particleSize.min, CONFIG.particleSize.max);
                
                // Geometry shapes
                const sides = Math.floor(Math.random() * 3) + 3; // 3 to 5 sides
                const body = Bodies.polygon(x, y, sides, size, {
                    frictionAir: 0.005,
                    restitution: 0.9,
                    render: { fillStyle: Math.random() > 0.5 ? '#fff' : '#444' }
                });
                
                particles.push(body);
                Composite.add(engine.world, body);
            }
            document.getElementById('obj-counter').innerText = `Particles: ${particles.length}`;
        }

        // --- Processing Loop ---

        let lastVideoTime = 0;
        let lastFrameTime = 0;
        let detectedLandmarks = null;

        function onPoseResults(results) {
            if (results.poseLandmarks) {
                detectedLandmarks = results.poseLandmarks;
                updateSkeletonPhysics(results.poseLandmarks);
            }
        }

        function updateSkeletonPhysics(landmarks) {
            // Helper to map 0-1 coords to screen width/height
            // Note: MediaPipe mirrors coordinates horizontally usually, but we want a mirror effect
            // x is 0(left) to 1(right). In webcam mirror:
            // If I move left hand (screen left), that's x close to 0.
            // But usually raw video is not mirrored. 
            // We will render video flipped, so we must flip X coordinate for physics to match visual.
            
            const getPos = (idx) => ({
                x: (1 - landmarks[idx].x) * width, // Flip X for mirror
                y: landmarks[idx].y * height
            });

            const updateBody = (key, idx) => {
                if (landmarks[idx] && landmarks[idx].visibility > 0.5) {
                    const target = getPos(idx);
                    // Direct position setting is simplest for "Kinetic" static bodies
                    Body.setPosition(skeletonBodies[key], target);
                } else {
                    // Move off screen if lost
                    Body.setPosition(skeletonBodies[key], {x: -1000, y: -1000});
                }
            };

            updateBody('head', 0); // Nose
            updateBody('l_shoulder', 11);
            updateBody('r_shoulder', 12);
            updateBody('l_elbow', 13);
            updateBody('r_elbow', 14);
            updateBody('l_wrist', 15);
            updateBody('r_wrist', 16);
        }

        async function loop(timestamp) {
            // FPS Calc
            const dt = timestamp - lastFrameTime;
            lastFrameTime = timestamp;
            if (timestamp % 20 < 1) { // Update FPS infrequently
                document.getElementById('fps-counter').innerText = `FPS: ${Math.round(1000/dt)}`;
            }

            // Send video to AI if ready
            if (video.currentTime !== lastVideoTime && video.readyState >= 3) {
                lastVideoTime = video.currentTime;
                await pose.send({image: video});
            }

            // Physics Step
            Engine.update(engine, 1000 / 60);

            // Render
            draw();

            requestAnimationFrame(loop);
        }

        function draw() {
            // 1. Clear & Background
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, width, height);

            // 2. Draw Camera Feed (Dimmed & Mirrored)
            ctx.save();
            ctx.scale(-1, 1); // Mirror
            ctx.translate(-width, 0);
            ctx.globalAlpha = 0.2; // Darken video
            
            // Draw video "cover" style
            const vRatio = video.videoWidth / video.videoHeight;
            const cRatio = width / height;
            if (cRatio > vRatio) {
                const h = width / vRatio;
                ctx.drawImage(video, 0, (height-h)/2, width, h);
            } else {
                const w = height * vRatio;
                ctx.drawImage(video, (width-w)/2, 0, w, height);
            }
            ctx.restore();

            // 3. Draw Geometry Overlay (Skeleton Lines)
            if (detectedLandmarks) {
                ctx.strokeStyle = '#00ffcc';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#00ffcc';
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                
                // Helper to get body pos from our physics objects (which are already smoothed/positioned)
                const pos = (key) => skeletonBodies[key].position;
                const vis = (key) => skeletonBodies[key].position.x > -500; // Check if on screen

                connections.forEach(([p1, p2]) => {
                    if (vis(p1) && vis(p2)) {
                        ctx.moveTo(pos(p1).x, pos(p1).y);
                        ctx.lineTo(pos(p2).x, pos(p2).y);
                    }
                });
                
                ctx.stroke();

                // Draw Nodes
                ctx.fillStyle = '#fff';
                for (let key in skeletonBodies) {
                    if (vis(key)) {
                        const p = pos(key);
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 5, 0, Math.PI*2);
                        ctx.fill();
                    }
                }
                
                // Reset Shadow
                ctx.shadowBlur = 0;
            }

            // 4. Draw Particles
            ctx.fillStyle = 'rgba(255,255,255,0.8)';
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;

            particles.forEach(p => {
                ctx.beginPath();
                const v = p.vertices;
                ctx.moveTo(v[0].x, v[0].y);
                for(let i=1; i<v.length; i++) ctx.lineTo(v[i].x, v[i].y);
                ctx.lineTo(v[0].x, v[0].y);
                
                // Color based on speed
                const speed = p.speed;
                if (speed > 2) ctx.fillStyle = '#00ffcc';
                else ctx.fillStyle = '#444';

                ctx.fill();
                ctx.stroke();
            });
        }

        document.getElementById('reset-btn').addEventListener('click', spawnParticles);
        
        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            // Wall updates omitted for brevity, but particles wrap anyway
        });
    </script>
</body>
</html>
